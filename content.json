[{"title":"异步加载与异步执行","date":"2016-12-23T14:22:06.000Z","path":"2016/12/23/异步加载与异步执行/","text":"异步(同步)加载 和 异步(同步)执行 的区别 异步加载（AMD）：多个js文件可同时下载，下载后无需立即执行，不会阻塞页面渲染script标签是会阻塞页面的 是同步的 下载的时候不会进行任何操作的 加了defer或async就可以同时下载和渲染之类的操作。变成了异步下载。 同步加载（commomjs）：js下载一个，然后马上执行，然后再下载下一个，然后又马上执行。此过程会阻塞页面渲染。 requires异步加载是指requires的模块是异步加载的，由于浏览器网速环境的限制，同步加载多个模块如果网络不好会影响页面渲染与交互，此时将模块做成异步，下载一个js模块不回影响另一个js模块的执行（如果这两个模块没有依赖关系），可以抵消一些网速影响带来的用户体验下降问题，所以浏览器端的模块化采用requirejs（AMD）。 commomjs同步加载是指commomjs的模块是同步加载的，必须加载完一个模块后再加载另一个模块，在服务器端（本地环境）由于不受网络环境影响，无需考虑同步加载阻塞的问题。此时采用commomjs组织模块化，模块语法会更清晰，所以服务器端（nodejs）的模块化采用commomjs。 同步执行与异步执行是js执行过程中的概念，就是平时所见的事件回调，ajax等等。","tags":[{"name":"模块","slug":"模块","permalink":"https://ra1ning.github.io/tags/模块/"}]},{"title":" jquery 兼容 commonjs","date":"2016-12-23T14:05:58.000Z","path":"2016/12/23/jquery-兼容-commonjs/","text":"最近在 webpack 中使用 jquery的时候注意到在 webpack 中使用全局变量需要插件来声明,看来jquery 为了不污染全局变量做了一些处理:判断当前执行环境中有没有 module 对象,如果有 module 则不将 jQuery 挂到 window 上.详见下图分析","tags":[{"name":"jquery 模块","slug":"jquery-模块","permalink":"https://ra1ning.github.io/tags/jquery-模块/"}]},{"title":"webpack 小结","date":"2016-12-23T14:01:02.000Z","path":"2016/12/23/webpack-小结/","text":"webpack多入口文件配置 webpack-dev-server配置及使用（本地服务器html文件引用资源文件与本地应用时的路径区别） webpack第三方静态库集合打包，当有多个入口引用了同一资源，各入口打包后的文件都会包含这一资源，用以下插件方法去重复资源： require ensure 代码分割，以便异步按需加载 基于web pack搭建前端工程解决方案探索 - dmyang - SegmentFault 12345678if(判断加载AB.js的条件(按需加载AB.js))&#123; require ensure([‘moduleA’,’moduleB’],function()&#123; //moduleA和moduleB会被打包为一个文件AB.js， var A=require(&apos;moduleA&apos;); var B=require(&apos;moduleB&apos;); //use A or B &#125;)&#125; webpack loader配置及使用 webpack 插件使用及配置 webpack中容易犯的错误一个入口文件不能依赖另一个入口文件 12345678910111213141516171819202122232425262728293031323334353637383940var webpack = require(&apos;webpack&apos;);module.exports=&#123; entry: &#123; page1: __dirname + &quot;/src/main.js&quot;, page2: __dirname + &quot;/src/index.js&quot;, // page3: __dirname + &quot;/src/king.js&quot;, //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出 vendor: [&quot;jquery&quot;,&quot;zepto&quot;,&quot;lodash&quot;] &#125;, output: &#123; path: __dirname + &quot;/dest&quot;, filename: &quot;[name].bundle.js&quot;, &#125;, plugins:[ new webpack.optimize.CommonsChunkPlugin(&#123; name: &quot;vendor&quot;, //将vendor中的模块提取到公共代码中， // name:[&quot;vendor&quot;,&quot;runtime&quot;],可以提取出webpack运行时， // 避免每次修改业务代码时影响库代码/* 1. 若不使用webpack.optimize.CommonsChunkPlugin插件，则其他引用过vendor中模块的chunk会将自身用到的vendor中的模块再打包一次，造成代码冗余，浪费带宽； 2. 将commonsChunk的name指定为vendor，可以保证vendor中的模块提取到commonsChunk中（即使vendor中的模块并未被共用），vendor中放置第三方代码库，第三方库一般不会改动，再配合minChunks:Infinity，可以保证vendor中只有第三方库，避免引入其他模块（若未使用Infinity，可能混入其他共用过的经常会修改的业务模块，影响vendor在客户端的缓存）*/ minChunks:Infinity, //⚠️mimChunk默认值为chunk数量 &#125;) ]&#125; list of plugins ProvidePlugin123456new webpack.ProvidePlugin(&#123; $:&quot;jquery&quot;, jQuery:&quot;jquery&quot;, &quot;window.jQuery&quot;:&quot;jquery&quot;&#125;),//这个可以使jquery变成全局变量，不用在自己文件require(&apos;jquery’)了,模块中可以直接使用","tags":[{"name":"webpack","slug":"webpack","permalink":"https://ra1ning.github.io/tags/webpack/"}]},{"title":"Vue.js 清单(三)","date":"2016-12-23T12:49:35.000Z","path":"2016/12/23/Vue-js-清单-三/","text":"整理了一下 vue.js 文档中的一些关键知识点 –组件 组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。###全局组件123Vue.component(&apos;my+component&apos;, &#123; // 选项&#125;) 单向数据流prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。 另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。 Prop 验证组件可以为 props 指定验证要求。如果未指定验证要求，Vue 会发出警告。当组件给其他人使用时这很有用。prop 是一个对象而不是字符串数组时，它包含验证要求： 12345678910111213141516171819202122232425262728293031Vue.component(&apos;example&apos;, &#123; props: &#123; // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组／对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: &apos;hello&apos; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) 自定义事件我们知道，父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！ 每个 Vue 实例都实现了事件接口(Events interface)，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 给组件绑定原生事件 有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v+on 。例如： &lt;my+component v+on:click.native=&quot;doTheThing&quot;&gt;&lt;/my+component&gt; 编译作用域在深入内容分发 API 之前，我们先明确内容的编译作用域。假定模板为：123&lt;child+component&gt; &#123; &#123; message &#125; &#125;&lt;/child+component&gt; message 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。","tags":[{"name":"vue","slug":"vue","permalink":"https://ra1ning.github.io/tags/vue/"}]},{"title":"Vue.js 清单(二)","date":"2016-12-23T12:19:04.000Z","path":"2016/12/23/Vue-js-清单-二/","text":"整理了一下 vue.js 文档中的一些关键知识点 –模板语法 各种 v-指令,进行数据绑定,{ {} }是 v-bind:text 的简写,{ {} }只能在尖括号之间插入 绑定html 元素的属性使用 v-bind:attr=“data” 语法 v-指令绑定的值可以使用 JavaScript 表达式:eg. 123&#123; &#123; number + 1 &#125; &#125;&#123; &#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt; 但有个限制就是，每个绑定都只能包含单个表达式(除了 v-for)，所以下面的例子都不会生效。 1234&lt;!-- 这是语句，不是表达式 --&gt;&#123; &#123; var a = 1 &#125; &#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123; &#123; if (ok) &#123; return message &#125; &#125; &#125; 两个最常用的v指令 v-bind 与 v-on 缩写:v-bind:href—————&gt;:hrefv-on:click——————&gt;:@click vue 实例的计算属性 $computed 与 $methods 属性的区别:$computed 的计算基于 $computed 依赖的值,只要其依赖的值没有发生变化,$computed 就会立即返回前一次计算的值.而 methods 则每次调用都会重新计算. computed 具体使用方法(注意其中 get 与 set 的思想); $watch 与 $computed,通常使用 computed 更好. (watch 多用于回调? watch 观察的数据被外部修改时,watch 才会被调用) v-if v-show v-elsev-if 与 v-show 的不同点 按键修饰符","tags":[{"name":"vue","slug":"vue","permalink":"https://ra1ning.github.io/tags/vue/"}]},{"title":"Vue.js 清单(一)","date":"2016-12-23T11:56:48.000Z","path":"2016/12/23/Vue-js-清单-一/","text":"整理了一下 vue.js 文档中的一些关键知识点 v-bind:attr=“data”eg. v-bind:title 绑定属性到元素上 v-if=“data” v-on:event=“handle” 绑定事件 在 Vue 里，一个组件实质上是一个拥有预定义选项的一个 Vue 实例 父子组件消息传递初探:父组件向子组件传值.子元组件暴露一个 props 字段给父组件,父组件将值赋给 props 属性,从而起到父组件传值给子组件的作用, 父子传值初探 在实例化 Vue 时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。全部的选项可以在 API 文档中查看。 可以扩展 Vue 构造器，从而用预定义选项创建可复用的组件构造器： var MyComponent = Vue.extend({ // 扩展选项 }) // 所有的 MyComponent 实例都将以预定义的扩展选项被创建 var myComponentInstance = new MyComponent() 每个 Vue 实例都会代理其 data 对象里所有的属性,只有这些被代理的属性是响应的。如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。 除了 data 属性， Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的 data 属性区分。eg. vm.$el===document.getElementById(‘example’) //true, 如果不加$,且 data 中刚好有个属性也叫 el ,此时 vm.$el 与 vm.el 混淆. 组件生命周期","tags":[{"name":"vue","slug":"vue","permalink":"https://ra1ning.github.io/tags/vue/"}]},{"title":"git常用命令","date":"2016-12-23T11:53:50.000Z","path":"2016/12/23/git常用命令/","text":"添加文件到Git仓库 使用命令git add ，注意，可反复多次使用，添加多个文件； 使用命令git commit，完成。 git常用命令 pwd-Print Working Directory HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 git reset –hard HEAD^ 回退到上一个版本库 git diff 用来比较工作区保存内容与缓存区内容之间的差异 git checkout —filename 将工作区内容回退到与最近最近记录暂存区相同 git reset HEAD file可以把暂存区的修改撤销掉（unstage），并重新放回工作区 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 将本地文件推送到 github git remote add origin git@github.com:michaelliao/.git git push -u origin master#参数u将本地仓库与远程建立关联之后推送文件到项目只需使用 ++git push -u origin master++","tags":[{"name":"git","slug":"git","permalink":"https://ra1ning.github.io/tags/git/"}]}]